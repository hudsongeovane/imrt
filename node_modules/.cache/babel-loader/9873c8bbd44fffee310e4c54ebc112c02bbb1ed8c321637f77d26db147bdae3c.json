{"ast":null,"code":"function isEqualSegment(a, b) {\n  for (i = 0; i < a.length; i++) {\n    if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return false;\n  }\n  return true;\n}\nfunction max(a, b) {\n  if (a > b) return a;\n  return b;\n}\nfunction solveRow(row) {\n  let line = row;\n  line.unshift(0);\n  line.push(0);\n  let p = [];\n  let q = [];\n  let L = 0;\n  for (i = 0; i < line.length; ++i) {\n    L = max(line[i], L);\n  }\n  for (k = 1; k <= L; ++k) {\n    for (i = 1; i < line.length; ++i) {\n      if (line[i - 1] < k && k <= line[i]) p.push(i);\n      if (line[i] >= k && k > line[i + 1]) q.push(i);\n    }\n  }\n  let lineSegments = [];\n  for (i = 0; i < p.length; i++) {\n    lineSegments.push([min(p[i], q[i]) - 1, max(p[i], q[i]) - 1]);\n  }\n  return lineSegments;\n}\nfunction bortfeld(matrix) {\n  let segments = [];\n  let coefficients = [];\n  let lineSegments = [];\n  let maxS = 0;\n  for (i = 0; i < matrix.length; i++) {\n    let solved_row = solveRow(matrix[i]);\n    lineSegments.push(solved_row);\n    maxS = max(maxS, solved_row.length);\n  }\n  for (k = 0; k < maxS; k++) {\n    let currentSegment = [];\n    for (i = 0; i < matrix.length; i++) {\n      tmp = [];\n      if (k < lineSegments[i].length) {\n        tmp = lineSegments[i][k];\n      } else {\n        if (segments.length == 0) tmp = [1, 0];else {\n          a = segments[-1][i][0];\n          b = segments[-1][i][1];\n          tmp = [max(a, b), max(a, b) - 1];\n        }\n      }\n      currentSegment.push(tmp);\n    }\n    sameSegment = false;\n    for (i = segments.length - 1; i >= 0; i--) {\n      if (isEqualSegment(currentSegment, segments[i])) {\n        coefficients[i]++;\n        sameSegment = true;\n        break;\n      }\n    }\n    if (!sameSegment) {\n      segments.push(currentSegment);\n      coefficients.push(1);\n    }\n  }\n  return [coefficients, segments];\n}","map":{"version":3,"names":["isEqualSegment","a","b","i","length","max","solveRow","row","line","unshift","push","p","q","L","k","lineSegments","min","bortfeld","matrix","segments","coefficients","maxS","solved_row","currentSegment","tmp","sameSegment"],"sources":["/Users/hmedeiros/react-study/imrt/src/algorithms/Bortfeld.js"],"sourcesContent":["function isEqualSegment(a, b) {\n    for(i = 0; i < a.length; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return false;\n    }\n    return true;\n}\n\n\nfunction max(a, b) {\n    if (a > b) return a;\n    return b;\n}\n\nfunction solveRow(row) {\n    let line = row;\n    line.unshift(0);\n    line.push(0);\n\n    let p = [];\n    let q = [];\n    let L = 0;\n    for(i = 0; i < line.length; ++i) {\n        L = max(line[i], L);\n    }\n    for(k = 1; k <= L; ++k) {\n        for(i = 1; i < line.length; ++i) {\n            if ((line[i-1] < k) && (k <= line[i])) p.push(i);\n            if ((line[i] >= k) && (k > line[i+1])) q.push(i);\n        }\n    }\n\n    let lineSegments = [];\n    for(i = 0; i < p.length; i++) {\n        lineSegments.push([min(p[i], q[i])-1, max(p[i], q[i]) - 1])\n    }\n    return lineSegments;\n}\n\nfunction bortfeld(matrix) {\n    let segments = [];\n    let coefficients = [];\n\n    let lineSegments = [];\n    let maxS = 0;\n    for(i = 0; i < matrix.length; i++) {    \n        let solved_row = solveRow(matrix[i]);\n        lineSegments.push(solved_row);\n        maxS = max(maxS, solved_row.length);\n    }\n\n    for(k = 0; k < maxS; k++) {\n        let currentSegment = [];\n        \n        for(i = 0; i < matrix.length; i++) {\n                tmp = [];\n                if (k < lineSegments[i].length) {\n                    tmp = lineSegments[i][k];\n                }\n                else {\n                    if (segments.length == 0)\n                        tmp = [1, 0];\n                    else {\n                        a = segments[-1][i][0];\n                        b = segments[-1][i][1];\n                        tmp = [max(a,b), max(a,b)-1];\n                    }\n                }\n                currentSegment.push(tmp);\n        }\n\n        sameSegment = false;\n        for(i = segments.length - 1; i >= 0; i--) {\n            if (isEqualSegment(currentSegment,segments[i])) {\n                coefficients[i]++;\n                sameSegment = true;\n                break;\n            }\n        }\n        if (!sameSegment) {\n            segments.push(currentSegment);\n            coefficients.push(1);\n        }\n    }\n    return [coefficients, segments];\n}"],"mappings":"AAAA,SAASA,cAAcA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC1B,KAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,CAAC,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1B,IAAIF,CAAC,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAID,CAAC,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIF,CAAC,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAID,CAAC,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,KAAK;EAC9D;EACA,OAAO,IAAI;AACf;AAGA,SAASE,GAAGA,CAACJ,CAAC,EAAEC,CAAC,EAAE;EACf,IAAID,CAAC,GAAGC,CAAC,EAAE,OAAOD,CAAC;EACnB,OAAOC,CAAC;AACZ;AAEA,SAASI,QAAQA,CAACC,GAAG,EAAE;EACnB,IAAIC,IAAI,GAAGD,GAAG;EACdC,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EACfD,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC;EAEZ,IAAIC,CAAC,GAAG,EAAE;EACV,IAAIC,CAAC,GAAG,EAAE;EACV,IAAIC,CAAC,GAAG,CAAC;EACT,KAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,IAAI,CAACJ,MAAM,EAAE,EAAED,CAAC,EAAE;IAC7BU,CAAC,GAAGR,GAAG,CAACG,IAAI,CAACL,CAAC,CAAC,EAAEU,CAAC,CAAC;EACvB;EACA,KAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAID,CAAC,EAAE,EAAEC,CAAC,EAAE;IACpB,KAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,IAAI,CAACJ,MAAM,EAAE,EAAED,CAAC,EAAE;MAC7B,IAAKK,IAAI,CAACL,CAAC,GAAC,CAAC,CAAC,GAAGW,CAAC,IAAMA,CAAC,IAAIN,IAAI,CAACL,CAAC,CAAE,EAAEQ,CAAC,CAACD,IAAI,CAACP,CAAC,CAAC;MAChD,IAAKK,IAAI,CAACL,CAAC,CAAC,IAAIW,CAAC,IAAMA,CAAC,GAAGN,IAAI,CAACL,CAAC,GAAC,CAAC,CAAE,EAAES,CAAC,CAACF,IAAI,CAACP,CAAC,CAAC;IACpD;EACJ;EAEA,IAAIY,YAAY,GAAG,EAAE;EACrB,KAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,CAAC,CAACP,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1BY,YAAY,CAACL,IAAI,CAAC,CAACM,GAAG,CAACL,CAAC,CAACR,CAAC,CAAC,EAAES,CAAC,CAACT,CAAC,CAAC,CAAC,GAAC,CAAC,EAAEE,GAAG,CAACM,CAAC,CAACR,CAAC,CAAC,EAAES,CAAC,CAACT,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;EAC/D;EACA,OAAOY,YAAY;AACvB;AAEA,SAASE,QAAQA,CAACC,MAAM,EAAE;EACtB,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,YAAY,GAAG,EAAE;EAErB,IAAIL,YAAY,GAAG,EAAE;EACrB,IAAIM,IAAI,GAAG,CAAC;EACZ,KAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,MAAM,CAACd,MAAM,EAAED,CAAC,EAAE,EAAE;IAC/B,IAAImB,UAAU,GAAGhB,QAAQ,CAACY,MAAM,CAACf,CAAC,CAAC,CAAC;IACpCY,YAAY,CAACL,IAAI,CAACY,UAAU,CAAC;IAC7BD,IAAI,GAAGhB,GAAG,CAACgB,IAAI,EAAEC,UAAU,CAAClB,MAAM,CAAC;EACvC;EAEA,KAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,IAAI,EAAEP,CAAC,EAAE,EAAE;IACtB,IAAIS,cAAc,GAAG,EAAE;IAEvB,KAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,MAAM,CAACd,MAAM,EAAED,CAAC,EAAE,EAAE;MAC3BqB,GAAG,GAAG,EAAE;MACR,IAAIV,CAAC,GAAGC,YAAY,CAACZ,CAAC,CAAC,CAACC,MAAM,EAAE;QAC5BoB,GAAG,GAAGT,YAAY,CAACZ,CAAC,CAAC,CAACW,CAAC,CAAC;MAC5B,CAAC,MACI;QACD,IAAIK,QAAQ,CAACf,MAAM,IAAI,CAAC,EACpBoB,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KACZ;UACDvB,CAAC,GAAGkB,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAChB,CAAC,CAAC,CAAC,CAAC,CAAC;UACtBD,CAAC,GAAGiB,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAChB,CAAC,CAAC,CAAC,CAAC,CAAC;UACtBqB,GAAG,GAAG,CAACnB,GAAG,CAACJ,CAAC,EAACC,CAAC,CAAC,EAAEG,GAAG,CAACJ,CAAC,EAACC,CAAC,CAAC,GAAC,CAAC,CAAC;QAChC;MACJ;MACAqB,cAAc,CAACb,IAAI,CAACc,GAAG,CAAC;IAChC;IAEAC,WAAW,GAAG,KAAK;IACnB,KAAItB,CAAC,GAAGgB,QAAQ,CAACf,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACtC,IAAIH,cAAc,CAACuB,cAAc,EAACJ,QAAQ,CAAChB,CAAC,CAAC,CAAC,EAAE;QAC5CiB,YAAY,CAACjB,CAAC,CAAC,EAAE;QACjBsB,WAAW,GAAG,IAAI;QAClB;MACJ;IACJ;IACA,IAAI,CAACA,WAAW,EAAE;MACdN,QAAQ,CAACT,IAAI,CAACa,cAAc,CAAC;MAC7BH,YAAY,CAACV,IAAI,CAAC,CAAC,CAAC;IACxB;EACJ;EACA,OAAO,CAACU,YAAY,EAAED,QAAQ,CAAC;AACnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}